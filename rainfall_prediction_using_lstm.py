# -*- coding: utf-8 -*-
"""Rainfall prediction using LSTM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WSbff9DOgSVgHEMg1dTtT6ftl9G_Yheu

importing libraries
"""

import tensorflow as tf
import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import mean_absolute_error as mae
from sklearn.metrics import mean_squared_error as mse
from sklearn.metrics import r2_score as r2s
from math import sqrt

"""Loading pre processed dataset version 2"""

df1=pd.read_csv('/content/uk_weather_data_preprocessed2.csv')
df1.head()

df1.columns

df1_cols=['year', 'month', 'tmax', 'tmin', 'af', 'rain', 'sun',
       'station']
df1=df1[df1_cols]
df1.head()

"""Resampling dataset based on armagh weather station as df1 and oxford station as df2"""

df1=df1.loc[df1['station']=='armagh']
df1.drop(['station'], axis=1, inplace=True)
df1['year']=df1['year'].astype(int)
df1['month']=df1['month'].astype(int)
df1["Date"] = pd.to_datetime(df1["year"].astype(str) + "/" + df1["month"].astype(str))
df1.head()

# df2=df1.loc[df1['station']=='oxford']
# df2.drop(['station'], axis=1, inplace=True)
# df2['year']=df2['year'].astype(int)
# df2['month']=df2['month'].astype(int)
# df2["Date"] = pd.to_datetime(df2["year"].astype(str) + "/" + df2["month"].astype(str))
# df2.head()

"""Setting index to Date feature"""

df1.index = pd.to_datetime(df1['Date'])
df1.head()


# df2.index = pd.to_datetime(df2['Date'])
# df2.head()

"""Taking 'rain' variable to make independent features and target variable and ploting the time siries plot"""

rainfall=df1['rain']
rainfall.plot()
plt.xticks(rotation=45)


# rainfall=df2['rain']
# rainfall.plot()
# plt.xticks(rotation=45)

# plt.savefig('/content/timesiriesoxford.png')

rainfall

"""Creating features and label from the time siries prediction variable 'rain'"""

# [[[1], [2], [3], [4], [5]]] [6]
# [[[2], [3], [4], [5], [6]]] [7]
# [[[3], [4], [5], [6], [7]]] [8]

def df_to_X_y(df, timestemps):
  df_as_np = df.to_numpy()
  X = []
  y = []
  for i in range(len(df_as_np)-timestemps):
    row = [[a] for a in df_as_np[i:i+timestemps]]
    X.append(row)
    label = df_as_np[i+timestemps]
    y.append(label)
  return np.array(X), np.array(y)

timestemps=50
X1, y1 = df_to_X_y(rainfall, timestemps)
X1.shape, y1.shape

X1

y1

X_train1, y_train1 = X1[:1500], y1[:1500]
X_val1, y_val1 = X1[1500:1800], y1[1500:1800]
X_test1, y_test1 = X1[1800:], y1[1800:]
X_train1.shape, y_train1.shape, X_val1.shape, y_val1.shape, X_test1.shape, y_test1.shape

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import *
from tensorflow.keras.callbacks import ModelCheckpoint
from tensorflow.keras.losses import MeanSquaredError
from tensorflow.keras.metrics import RootMeanSquaredError
from tensorflow.keras.optimizers import Adam

model1 = Sequential()

model1.add(LSTM(32, activation='tanh', input_shape=(X_train1.shape[1], X_train1.shape[2])))

model1.add(Dense(1))

model1.summary()

cp1 = ModelCheckpoint('model1/', save_best_only=True)
model1.compile(loss=MeanSquaredError(), optimizer=Adam(learning_rate=0.0001), metrics=[RootMeanSquaredError()])

model1.fit(X_train1, y_train1, validation_data=(X_val1, y_val1), epochs=100, batch_size=5, callbacks=[cp1])

from tensorflow.keras.models import load_model
model1 = load_model('model1/')

train_predictions = model1.predict(X_train1).flatten()
train_results = pd.DataFrame(data={'Train Predictions':train_predictions, 'Actuals':y_train1})
train_results[:30]

import matplotlib.pyplot as plt
plt.plot(train_results['Train Predictions'][100:200])
plt.plot(train_results['Actuals'][100:200])

val_predictions = model1.predict(X_val1).flatten()
val_results = pd.DataFrame(data={'Val Predictions':val_predictions, 'Actuals':y_val1})
val_results

plt.plot(val_results['Val Predictions'][:100])
plt.plot(val_results['Actuals'][:100])

test_predictions = model1.predict(X_test1).flatten()
test_results = pd.DataFrame(data={'Test Predictions':test_predictions, 'Actuals':y_test1})
test_results[:20]

test_results.iloc[:, 0]

plt.plot(test_results['Test Predictions'][:100])
plt.plot(test_results['Actuals'][:100])
plt.savefig('/content/olstmtestresfig.png')

"""Performance measures"""

mae1=mae(test_results.iloc[:, 1],test_results.iloc[:, 0])
mse1=mse(test_results.iloc[:, 1],test_results.iloc[:, 0])
print(mae1)
# print(mse1)
rmse1=sqrt(mse1)
print(rmse1)
r2_score=r2s(test_results.iloc[:, 1],test_results.iloc[:, 0])
print(r2_score)

"""Using Stacked LSTM"""

model=Sequential()
model.add(LSTM(32,activation='relu',input_shape=(X_train1.shape[1],X_train1.shape[2]),return_sequences=True))
model.add(Dropout(0.3))

model.add(LSTM(32,activation='relu',return_sequences=True))
model.add(Dropout(0.3))

model.add(LSTM(32,activation='relu',return_sequences=False))
model.add(Dropout(0.3))

model.add(Dense(1))

model.summary()

cp = ModelCheckpoint('model/', save_best_only=True)
model.compile(loss=MeanSquaredError(), optimizer=Adam(learning_rate=0.0001), metrics=[RootMeanSquaredError()])

model.fit(X_train1, y_train1, validation_data=(X_val1, y_val1), epochs=100, batch_size=5, callbacks=[cp])

from tensorflow.keras.models import load_model
model = load_model('model/')

train_predictions = model.predict(X_train1).flatten()
train_results = pd.DataFrame(data={'Train Predictions':train_predictions, 'Actuals':y_train1})
train_results

import matplotlib.pyplot as plt
plt.plot(train_results['Train Predictions'][:100])
plt.plot(train_results['Actuals'][:100])

val_predictions = model.predict(X_val1).flatten()
val_results = pd.DataFrame(data={'Val Predictions':val_predictions, 'Actuals':y_val1})
val_results

plt.plot(val_results['Val Predictions'][:100])
plt.plot(val_results['Actuals'][:100])

test_predictions = model.predict(X_test1).flatten()
test_results = pd.DataFrame(data={'Test Predictions':test_predictions, 'Actuals':y_test1})
test_results[:15]

plt.plot(test_results['Test Predictions'][:])
plt.plot(test_results['Actuals'][:])
plt.savefig('/content/oxlstmtestresfig.png')

"""Performance measures"""

mae1=mae(test_results.iloc[:, 1],test_results.iloc[:, 0])
mse1=mse(test_results.iloc[:, 1],test_results.iloc[:, 0])
print(mae1)
# print(mse1)
rmse1=sqrt(mse1)
print(rmse1)
r2_score=r2s(test_results.iloc[:, 1],test_results.iloc[:, 0])
print(r2_score)

